## 투포인터
- 배열이나 문자열에서 두 개의 포인터(start,end)를 활용하여 문제를 푸는 기법
- 직관적이다.

## 누적합
- 배열을 하나의 숫자로 압축해서 주어진 인접행렬에서 [i+1][j+1]에 대한 합을 계산한다.
- 생각했을 때에는 주어진 문제에 대한 패턴을 찾는 것이 핵심이다.
- 일단 N[i+1][j] + N[i][j+1] - N[i][j] + A[i+1][j+1] 쓰고 시작한다.

## 비교
# 백준 1806번 부분합
- 투포인터가 누적합을 이기는 경우이다.
```python3
#누적합
n,s = map(int,input().split())
a = list(map(int,input().split()))
def sol():
    dp = [0]*(n+1)
    ans = 100001
    for j in range(1,n+1):
        dp[j] = dp[j-1] + a[j-1]
        for i in range(max(0,j-ans),j):
            if dp[j]-dp[i] < s:
                break
            ans = min(ans,j-i)
    if ans == 100001:
        print(0)
    else:
        print(ans)
sol()
```

```python3
#투포인터
n,s = map(int,input().split())
a = list(map(int,input().split()))
def sol():
    # 부분합, 부분수열의 시작점, 끝점
    sub, start, end = 0, 0, 0
    ans = 100001
    # 한칸씩 이동하면서 부분합을 비교
    while True:
        # 만약 부분합이 s보다 크면 부분합의 길이를 업데이트
        if sub >= s:
            ans = min(ans, end - start)
            # 시작점을 오른쪽으로 한칸 이동하면서 이전에 더해준 값은 빼주기
            sub -= a[start]
            start += 1
        else:
            # 마지막을 넘었다면 멈추기
            if end == n:
                break
            # 부분합이 s보다 작으면 끝점을 오른쪽으로 한칸이동
            sub += a[end]
            end += 1            
    if ans == 100001:
        print(0)
    else:
        print(ans)
sol()
```

```text
누적합 방법 (sol 함수 1)  
시간 복잡도: O(n^2)  
- 이중 루프를 사용하여, 각 j에 대해 i를 최대 j-ans까지 반복하며 부분합을 계산. 최악의 경우 n번 반복, 내부 루프도 최대 n번 수행 가능.  
공간 복잡도: O(n)  
- dp 배열 크기 n+1을 사용하여 누적합 저장.

투포인터 방법 (sol 함수 2)  
시간 복잡도: O(n)  
- start와 end 포인터가 각각 최대 n번 이동하며, 전체 배열을 한 번씩만 순회.  
공간 복잡도: O(n)  
- a 리스트와 상수 변수들만 사용, 추가적인 큰 자료구조 없음.

요약하면, 투포인터 방법이 시간 복잡도 면에서 훨씬 효율적이며, 두 방법 모두 공간 복잡도는 비슷하다.
```

<br>

# 백준 11659번 구간 합 구하기4
- 누적합이 투포인터를 이기는 경우이다.
```python3
import sys
input = sys.stdin.readline
m,n=map(int,input().split())
arr=list(map(int,input().split()))
prefix_sum=[0]    
temp=0    
for i in arr:    
    temp+=i
    prefix_sum.append(temp)
for i in range(n):
    a,b=map(int,input().split())
    print(prefix_sum[b]-prefix_sum[a-1])
```

```python3
# 투포인터(시간초과)
import sys
input = sys.stdin.readline

n, q = map(int, input().split())
arr = list(map(int, input().split()))

for _ in range(q):
    i, j = map(int, input().split())
    i -= 1  # 0-index 맞춤
    j -= 1

    start = i
    end = i
    sub_sum = 0

    while end <= j:
        sub_sum += arr[end]
        end += 1

    print(sub_sum)
```

```text
누적합 방법의 시간 복잡도는 O(m + n)이다.
m은 배열의 길이, n은 쿼리의 수이며, 배열의 누적합을 계산하는 데 O(m),
각 쿼리마다 구간 합을 계산하는 데 O(1) (이전 계산된 누적합을 이용)으로 전체적으로 O(m + n)이다.
공간 복잡도는 O(m)으로, 누적합 배열을 저장하는 데 필요하다.

투포인터 방법의 시간 복잡도는 최악의 경우 O(n * q)이다.
각 쿼리마다 시작 인덱스부터 끝 인덱스까지 반복하며 구간 합을 계산하기 때문에,
쿼리 수 q와 배열 길이 n에 따라 성능이 저하될 수 있다.
공간 복잡도는 O(n)으로, 배열을 저장하는 데 필요하다.
```


| 문제                  | 접근법  | 시간복잡도             | 공간복잡도  | 특징                                           | 통과 여부       |
| ------------------- | ---- | ----------------- | ------ | -------------------------------------------- | ----------- |
| **1806 부분합**        | 누적합  | O(n²) (부분합 반복 계산) | O(n+1) | 각 끝점 j마다 가능한 시작점 i 모두 탐색                     | 통과 가능하지만 느림 |
|                     | 투포인터 | O(n)              | O(1)   | 연속 구간 조건 **단조(Monotone:한 방향 성질)** 활용 → start/end 포인터 이동으로 최소 길이 탐색 | 통과, 효율적     |
| **11659 구간 합 구하기4** | 누적합  | O(n+q)            | O(n+1) | prefix sum으로 임의 구간 합 O(1) 조회                 | 통과, 필수      |
|                     | 투포인터 | O(n\*q)           | O(1)   | 쿼리마다 start→end 이동, 임의 구간 → 재사용 불가            | 시간초과        |


