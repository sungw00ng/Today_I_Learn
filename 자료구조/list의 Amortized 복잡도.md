# Python list.append()의 Amortized 시간복잡도

Python의 `list.append()`는 **Amortized O(1)**의 시간복잡도를 가짐.<br>
Amortized라는 용어는 평균적인 비용을 계산할 때 사용하는 개념으로, <br>
전체 작업을 여러 번에 걸쳐 나누었을 때 각 작업의 평균 비용을 의미함.<br>
특정 작업이 자주 수행되는 동안 일부 작업은 시간이 많이 걸릴 수 있지만,<br>
전체적으로 봤을 때 평균적으로 비용이 적게 드는 경우가 있을 때 <br>
Amortized 복잡도를 사용.<br>
<br>
Python 리스트는 **내부적으로 동적 배열(Dynamic Array)** 구조를 사용하며, <br>
다음과 같은 방식으로 동작함.<br>
<br>
## 동작 방식

1. 리스트는 연속된 메모리 공간에 요소를 저장하는 배열로 구현되어 있음.
2. `append()` 호출 시:
    - 여유 공간이 있다면 해당 위치에 값을 삽입 → O(1)
    - 여유 공간이 없다면:
        - 더 큰 배열을 새로 할당 (보통 현재 크기의 2배 등)
        - 기존 요소를 새 배열로 복사
        - 새로운 요소 추가 → O(n)

3. 이 과정이 **자주 일어나지 않도록** 설계되어 있기 때문에, <br>
전체적으로 보면 `n`번의 `append()` 호출에 대해 총 시간복잡도는 O(n),<br>
 즉 **한 번당 평균 O(1)**로 계산.

## 요약

| 상황                     | 시간복잡도       |
|--------------------------|------------------|
| 메모리 여유가 있을 때    | O(1)             |
| 메모리 부족 시 재할당    | O(n)             |
| 평균 (Amortized)         | **O(1)**         |

Python의 동적 배열은 이처럼 메모리를 **기하급수적으로 증가시키는 전략**을 통해<br>
재할당 횟수를 최소화하여 `append()`를 매우 효율적인 연산으로 유지합니다.
