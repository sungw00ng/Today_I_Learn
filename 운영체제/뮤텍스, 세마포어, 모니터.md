## 뮤텍스, 세마포어, 모니터
- 경쟁상태를 해결하는 대표적인 방법들이다.

## 어떠한 조건들이 있었는가
#### 상호 배제(mutual exclusion)
- 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.

#### 한정 대기(bounded waiting)
- 특정 프로세스가 영원히 임계 영역에 들어가지 못하게 하는 것을 방지(횟수제한)

#### 진행의 융퉁성(progress)
- 임계영역 아무도 안쓰면 외부 프로세스가 진입 가능
- 이 때, 프로세스끼리 서로 방해하지 않는 것

## 뮤텍스(mutex)
<img width="918" height="334" alt="a1 (23)" src="https://github.com/user-attachments/assets/c7411d63-c76f-462e-bbd2-ef31b3c63b14" /><br>
##### 출처 : https://heeonii.tistory.com/14
##### 그림 : Mutex

> ex) 변기가 1개인 화장실
 
- 공유 자원을 객체 lock(lock - unlock) 을 기반으로 경쟁상태를 해결
- 한 번에 하나의 프로세스만 임계영역에 있을 수 있다.

```java
import java.util.concurrent.locks.ReentrantLock;

public class MutexExample {
    private static final ReentrantLock mutex = new ReentrantLock();

    public static void main(String[] args) {
        Thread t1 = new Thread(MutexExample::criticalSection);
        Thread t2 = new Thread(MutexExample::criticalSection);

        t1.start();
        t2.start();
    }

    static void criticalSection() {
        mutex.lock();  // wait
        try {
            // 임계 영역
            System.out.println(Thread.currentThread().getName() + " is in the critical section.");
            try { Thread.sleep(1000); } catch (InterruptedException ignored) {}
        } finally {
            mutex.unlock();  // signal
        }
    }
}
```

## 세마포어(semaphore)
<img width="839" height="569" alt="a1 (24)" src="https://github.com/user-attachments/assets/d5cd0931-0c30-44ad-932c-15c9f5800f35" /><br>
##### 출처 : https://heeonii.tistory.com/14
##### 그림 : Semaphore
> ex) 5명의 사용자만이 로그인하여 들어갈 수 있는 게임

- 일반화된 뮤텍스로, 간단한 정수 S와 두 가지 함수 wait(), signal()로 공유 자원 접근 처리
- 한 번에 여러 프로세스가 동시에 임계영역에 접근 가능
- S는 쓸 수 있는 공유자원의 수
- wait()는 S-=1, 음수가 될 시 프로세스 차단 후 대기열에 삽입
- signal()는 S+=1, 공유자원을 프로세스가 다 쓴 상태로 S가 0이하라면 대기열의 프로세스가 동작
- 바이너리 세마포어(0 or 1), 카운팅 세마포어(여러개의 값)로 나뉠 수 있다.
- 상호배제를 명시적으로 구현해야 한다.
- 정수 변수 기반으로 구축된다.
 
```java
import java.util.concurrent.Semaphore;

public class GameRoom {
    // 최대 5명까지 동시에 입장 가능
    private static final Semaphore gameRoom = new Semaphore(5);

    public static void main(String[] args) {
        // 10명의 플레이어 시뮬레이션
        for (int i = 1; i <= 10; i++) {
            int playerId = i;
            new Thread(() -> enterGame(playerId)).start();
        }
    }

    static void enterGame(int playerId) {
        try {
            System.out.println("Player " + playerId + " is trying to enter the game.");
            gameRoom.acquire();  // 입장 시도 (허용된 인원 초과 시 대기)
            System.out.println("Player " + playerId + " entered the game.");
            
            // 게임 중...
            Thread.sleep(2000);

        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            System.out.println("Player " + playerId + " left the game.");
            gameRoom.release();  // 퇴장 → 세마포어 해제
        }
    }
}
```

## 모니터
![a1 (1)](https://github.com/user-attachments/assets/0cd202a0-280c-43a3-8e73-d2fd5bd757a4)<br>
##### 출처 : https://velog.io/@moonheekim0118/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%AA%A8%EB%8B%88%ED%84%B0-Monitor
##### 그림 : 모니터(Monitor)

> ex) 창고에 물건을 넣고 빼는 생산자-소비자 문제 (1칸짜리 창고)

- 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공하는 객체
- 공유 자원에 추가 접근 시 큐에 작업으로써 추가된다.
- 상호배제가 자동이다.
- 공유 자원 순차적 처리

```java
class Store {
    private int item = 0;  // 0이면 비어 있음, 1이면 가득 참

    // synchronized 메서드: 모니터에 의해 보호됨
    public synchronized void produce() throws InterruptedException {
        while (item == 1) {
            wait();  // 창고가 가득 차면 기다림
        }
        item = 1;
        System.out.println("Produced an item.");
        notify();  // 소비자에게 알림
    }

    public synchronized void consume() throws InterruptedException {
        while (item == 0) {
            wait();  // 창고가 비어 있으면 기다림
        }
        item = 0;
        System.out.println("Consumed an item.");
        notify();  // 생산자에게 알림
    }
}

public class MonitorExample {
    public static void main(String[] args) {
        Store store = new Store();

        Thread producer = new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    store.produce();
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {}
        });

        Thread consumer = new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    store.consume();
                    Thread.sleep(800);
                }
            } catch (InterruptedException e) {}
        });

        producer.start();
        consumer.start();
    }
}
```




