## 컴파일러와 인터프리터의 작동 방식<br>

프로그래밍 언어로 작성된 우리의 코드는 컴퓨터가 직접 이해할 수 있는 언어, 즉 기계어로 변환되어야 실행될 수 있다. 마치 외국어로 쓰인 문서를 이해하기 위해 번역이 필요한 것과 같다. 이 번역 작업을 수행하는 주요 도구가 바로 컴파일러와 인터프리터다.<br>

### 컴파일러 (Compiler): 문서 전체를 번역하는 방식<br>

컴파일러는 우리가 작성한 소스 코드 전체를 마치 한 권의 책처럼 처음부터 끝까지 쭉 읽어 들여, 그 내용 전체를 컴퓨터가 이해할 수 있는 기계어라는 언어로 번역한다. 이 번역된 결과물은 마치 번역된 책처럼, 별도의 번역 과정 없이 언제든 다시 읽을 수 있는 실행 파일의 형태로 저장된다. 일단 컴파일이 완료되면, 이 실행 파일은 매우 빠른 속도로 작동할 수 있다. 마치 원서를 읽는 것보다 번역본을 읽는 것이 더 빠를 수 있는 것처럼. C, C++, Go, Rust와 같은 언어들이 주로 이러한 컴파일러 방식을 사용한다.<br>
하지만 책의 내용이 조금이라도 바뀌면, 우리는 번역된 책 전체를 다시 번역해야 한다. 마찬가지로, 소스 코드를 수정하면 전체 코드를 다시 컴파일해야 한다는 번거로움이 있다.<br>

### 인터프리터 (Interpreter): 문장을 즉석에서 통역하는 방식<br>

반면, 인터프리터는 마치 외국어 연설을 듣고 즉석에서 통역해 주는 통역사와 비슷하다. 우리가 작성한 소스 코드를 한 줄씩 읽어 들이고, 그 즉시 해당하는 기계어 코드로 번역하여 실행한다. 번역된 내용을 따로 저장해두지 않기 때문에, 마치 통역이 끝나면 그 내용이 휘발되는 것과 같다. 따라서 프로그램을 실행할 때마다 매번 번역 과정을 거쳐야 하므로, 미리 전체를 번역해 둔 컴파일러 방식에 비해 전체적인 실행 속도는 느릴 수 있다. 하지만 코드를 수정했을 때 전체를 다시 컴파일하는 과정 없이 바로 실행 결과를 확인할 수 있다는 편리함이 있다. Python이 대표적인 인터프리터 방식의 언어다.<br>

### JIT(Just-In-Time) 컴파일러: 필요할 때 즉시 번역하는 똑똑한 방식<br>

JIT(Just-In-Time) 컴파일러는 컴파일러와 인터프리터의 장점을 절충한, 더욱 똑똑한 번역 방식이라고 할 수 있다. 마치 숙련된 통역사가 자주 사용되는 문구나 중요한 부분을 미리 파악해 두었다가, 필요할 때 즉시 고품질로 번역해 주는 것과 유사하다.<br>

* **코드 분석 및 핫 스팟 식별:** JIT 컴파일러는 프로그램이 실제로 실행되는 동안 어떤 코드 부분이 자주 반복되는지, 즉 **핫 스팟(hot spot)**을 지능적으로 분석한다. 마치 통역사가 연설의 핵심 주제나 반복되는 어구를 파악하는 것과 같다. 프로그램 실행 전에 미리 모든 코드를 분석하는 것이 아니다.<br>
* **동적 컴파일:** 자주 실행되는 핫 스팟 코드를 파악하면, JIT 컴파일러는 이 부분만을 선별적으로 컴퓨터가 직접 이해할 수 있는 최적화된 기계어 코드로 동적 컴파일한다. 마치 통역사가 중요한 발언에 대해 더욱 정확하고 빠르게 통역할 준비를 하는 것과 같다. 이 컴파일 과정은 프로그램이 멈추지 않고 계속 실행되는 중에 이루어진다.<br>
* **최적화:** 컴파일 과정에서 단순히 기계어로 번역하는 것뿐만 아니라, 메모리 접근 방식을 개선하거나 불필요한 연산을 줄이는 등 다양한 최적화 기법을 적용하여 실행 효율성을 극대화한다. 마치 통역사가 문맥을 파악하여 더욱 자연스럽고 의미 전달이 명확한 통역을 제공하는 것과 같다.<br>
* **실행:** 이렇게 컴파일된 고품질의 기계어 코드는 이후에 해당 부분이 실행될 때마다 즉시 사용되어 프로그램의 전체적인 실행 속도를 향상시킨다. 마치 중요한 발언이 통역되자마자 청중이 그 내용을 빠르게 이해하고 반응할 수 있게 되는 것과 같다. 프로그램이 계속 실행되면서 새로운 핫 스팟이 발견되면, 해당 부분 역시 JIT 컴파일을 통해 최적화된다.<br>

Java Virtual Machine(JVM), .NET CLR, Node.js의 V8 엔진과 같은 환경들이 JIT 컴파일러를 핵심 기술로 채택하여 프로그램의 성능을 끌어올린다.<br>
JIT 컴파일러에는 몇 가지 흥미로운 기술들이 더 숨어있다.<br>

* **On-Stack Replacement (OSR):** 오랫동안 실행되는 반복문(루프)의 경우, 루프가 완전히 끝날 때까지 기다리지 않고 중간에 컴파일된 코드로 **교체(replacement)**하여 나머지 반복을 더 빠르게 실행하는 기술이다. 마치 긴 연설 중간에 중요한 부분이 더 효율적인 통역 방식으로 바뀌는 것과 같다.<br>
* **Tiered Compilation:** 처음에는 빠르게 컴파일하는 C1 컴파일러를 사용하여 프로그램의 초기 실행 속도를 높이고, 이후 더 많은 실행 정보를 얻은 후에는 더 심층적인 최적화를 수행하는 C2 컴파일러를 적용하는 계층화된 컴파일 방식이다. 마치 초벌 번역 후 최종 감수를 거치는 것과 유사하다.<br>
* **Deoptimization:** 때로는 컴파일러가 너무 공격적으로 최적화를 수행하여 오히려 성능이 저하되는 경우가 발생할 수 있다. 이럴 때 JIT 컴파일러는 이전에 수행했던 최적화를 되돌리는(deoptimization) 과정을 거쳐 다시 더 나은 방식으로 컴파일을 시도한다. 마치 잘못된 번역을 수정하는 것과 같다.<br>
* **Code Cache:** JIT 컴파일러가 생성한 최적화된 기계어 코드는 코드 캐시라는 특별한 메모리 영역에 저장된다. 마치 자주 사용하는 번역 용어집을 만들어두는 것과 같다. Java 11부터는 이 코드 캐시가 여러 영역으로 나뉘어 더욱 효율적으로 관리된다. 하지만 이 코드 캐시의 크기가 제한되어 있기 때문에, 너무 많은 코드가 컴파일되면 더 이상 새로운 코드를 컴파일할 수 없게 될 수도 있다.<br>

결론적으로 JIT 컴파일러는 인터프리터의 유연성과 컴파일러의 빠른 실행 속도를 모두 활용하여 프로그래밍 언어의 성능을 최적화하는 매우 중요한 기술이다. 마치 능숙한 통역사가 상황에 맞춰 유연하고 정확하게 번역함으로써 의사소통의 효율성을 높이는 것과 같다.<br>
