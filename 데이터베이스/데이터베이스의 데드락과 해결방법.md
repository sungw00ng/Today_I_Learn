## DB데드락
- 트랜잭션 간에 서로가 가진 자원을 기다리면서 무한정 대기 상태에 빠지는 현상이다.
- 트랜잭션 1: A->B 순서로 락 필요
- 트랜잭션 2: B->A 순서로 락 필요
>1. T1이 A에 락을 잡음 <br>
>2. T2가 B에 락을 잡음 <br>
>3. T1은 B를 기다림 <br>
>4. T2는 A를 기다림 <br>
==> 서로 대기 상태 → 데드락 <br>

<br><br>

## 데드락 발생 조건
- 1. 상호 배제(Mutual Exclusion) : 한 자원은 한 트랙잭션에만 사용 가능하다.
- 2. 점유 대기(Hold and Wait) : 자원을 가진 상태에서 다른 자원을 기다린다.
- 3. 비선점(Non-preemption) : 다른 트랜잭션이 강제로 자원을 빼앗을 수 없다.
- 4. 순환 대기(Circular Wait) : 트랜잭션들이 원형 대기 상태이다.

<br><br>

## 해결방법1: 데드락 탐지
### 1. timeout
- timeout 후 트랜잭션이 실행되지 않았을 경우 ROLLBACK한다.
- 직접 탐지는 아니지만 교착상태로 정의해서 탐지하는 방법이다.
- 구현이 간단하고 상황 해결이 빠르지만, 타임아웃 시간 설정이 어렵다.

### 2. wait for graph
- 트랜잭션 대기 그래프를 만들고 해당 그래프에 사이클이 발생됨을 주기적으로 검사한다.
- 모두 감지하는 것은 cost가 크므로, 보통은 `timeout`과 `데드락방지방법`을 쓴다.

<br><br>

## 해결방법2 : 데드락 방지
- 데드락 방지란 처음부터 데드락이 일어나지 않도록 방지하는 것이다.

### 1. 격리수준 변경
- REPEATABLE_READ -> serializable (단, serializable가 아니라면 모든 데드락 제거X)

### 2. 자원 할당 순서 지정(Ordering of Resource Allocation)
- 자원할당이 교착상태가 발생하지 않도록 서비스의 논리구조를 바꾸는 것이다.
- 예를 들어, table1 > table2 식으로, 교차 없이 일관성있게 바꾸는 방법이 있다.

### 3. wait-die 방법
- timestamp 기반으로 오래된 트랜잭션을 좀 더 우선순위가 높다고 판정하여,
- 이에 따라 대기(wait), 죽음(die or rollback) 등을 하는 `비선점기법`이다.
- 즉, 늙은 트랜잭션은 기다릴 수 있고, 젊은 트랜잭션은 죽는다는 규칙이다.
> wait: T5가 T10이 점유한 자원을 요청하면 T5는 대기한다. <br> 
> die: 반대로 T10이 T5가 점유한 자원을 요청하면 T10 ROLLBACK 후 다시 시도한다. <br>

### 4. wound - wait
- wait-die와 같지만 이는 `선점기법`이다.
>부상(wound):우선순위가 낮은 트랜잭션에 의해 이미 자원이 점유되어있다면, 이를 `부상`시킨다. <br>
>해당 트랜잭션의 점유자원을 강제로 해제하고 우선순위가 높은 트랜잭션에게 넘겨준다. <br>

>wait:반대로, 우선순위가 높은 트랜잭션에 의해 이미 자원이 점유되어 있다면, <br>
>우선순위가 낮은 트랜잭션은 높은 우선순위를 가진 트랜잭션의 해제까지 대기한다. <br>
