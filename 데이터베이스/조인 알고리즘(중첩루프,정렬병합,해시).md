### 데이터베이스의 조인, 내부 DB 알고리즘
```sql
FROM A
JOIN B
ON A.id=B.id
```

### 옵티마이저가 선택하는 기준
```pgsql
   +--------------------------+
   |        JOIN 시작         |
   +--------------------------+
                |
                v
   +--------------------------+
   | 조인 조건에 인덱스 존재? |
   +--------------------------+
        |               |
       Yes             No
        |               |
        v               v
+----------------+   +----------------+
| 중첩 루프+인덱스|   | 중첩 루프 전체  |
+----------------+   +----------------+
        |
        v
+----------------+
| 데이터 크기 확인 |
+----------------+
        |
        v
+----------------+
| 큰 테이블이면   |
| 정렬 병합/해시  |
| 조인 고려      |
+----------------+
```

### python
```python3

table1=[{'id':1,'name':'Alice'},{'id':2,'name':'Bob'}]
table2=[{'id':1,'age':25},{'id':2,'age':30}]
table1_sorted=sorted(table1,key=lambda x:x['id']) #join id 
table2_sorted=sorted(table2,key=lambda x:x['id']) #join id 
hash_table={row['id']: row for row in table2} #build 

# 중첩 루프 조인 O(N*M)
result=[]
for row1 in table1:
    for row2 in table2:
        if row1['id']==row2['id']:
            result.append({**row1,**row2})
print("중첩 루프 조인 결과")
print(result)

# 정렬 병합 조인 O(N log N + M log M) + O (N + M)
result=[]
i=j=0
while i<len(table1_sorted) and j<len(table2_sorted):
    if table1_sorted[i]['id']==table2_sorted[j]['id']:
        result.append({**table1_sorted[i],**table2_sorted[j]})
        i+=1
        j+=1
    elif table1_sorted[i]['id']<table2_sorted[j]['id']:
        i+=1
    else:
        j+=1
print("정렬 병합 조인 결과")
print(result)


# 해시 조인 O(N + M)
result=[]
#probe
for row1 in table1:
    if row1['id'] in hash_table:
        result.append({**row1,**hash_table[row1['id']]})
print("해시 조인 결과")
print(result)

```
<img src="https://github.com/user-attachments/assets/b0a68c31-f93a-42c1-803e-d6009523382b"/><br>
